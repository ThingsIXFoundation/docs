---
sidebar_position: 3
---

# For gateway owners
Each gateway that is added to ThingsIX must go through an onboarding process.
During this process the identity of the gateway and owner are determined and
registered in the ThingsIX gateway registry. The owner can then update the
gateway details so the gateway joins the ThingsIX network.

Gateway manufacturers will provide instructions how to onboard their gateways in
ThingsIX. This section is aimed at people that want to understand the onboard
process to  onboard their own ThingsIX gateways or are just interested what is
happening behind the scenes.

## Register gateway at ThingsIX
The ThingsIX gateway registry is a smart contract that keeps track of each
registered gateway, its owner and details. With this information ThingsIX can
calculate earned rewards for each gateway and create cheques for gateway owners
to claim these rewards.

The gateway registry is a smart contract deployed on each of the supported
chains. Currently [Ethereum](https://ethereum.org) and 
[Polygon](https://polygon.technology) are supported but ThingsIX might support
additional chains in the future. Choosing between them is a personal decision
where Ethereum is well known and better integrated in exchanges while Polygon
offers lower transactions fees. Choose which one suits your needs the best.

:::note
There is no bridge between blockchains that allow registries to check other
registries if a gateway is already onboarded. Therefore it is possible to
onboard the same gateway in registries on multiple chains. ThingsIX will only
pay rewards on the chain the gateway was first registered. If the gateway must
be transferred to another chain it first must be deleted from the existing
registry. And only then registered in the new registry.
:::

## Identities
Gateways and their owners are identified by ECDSA keys. These are generated by
the gateway and user with their preferred software.

### Owner identity
An owner identity can be generated through one of the wallet solutions that
supports the chain the user wants to use. Since the owner needs to interact with
the gateway registry contract and claim `THIX` reward cheques the wallet must
support sending custom transactions through the ThingsIX dashboard. Support for
ERC-20 is optional but convenient since the `THIX` token contract is ERC-20
compatible.

Please follow the instruction provided by your wallet manufacturer to generate
an account and backup the key or seed phrase. If you loose access to your keys
we won't be able to help you to recover them. In this tutorial we will be using
[Metamask](https://metamask.io). Metamask supports Ethereum and Polygon,
integrates with the ThingsIX dashboard and supports various hardware tokens to
securely store your keys. On first use Metamask will guide the user through a
wizzard to create and backup an account.

### Gateway identity
Gateways are identified by an ECDSA keypair on the secp256 curve. The private
key must be stored on the gateway. The public key is used as its public identity
and stored in the gateway registry smart contract.

:::caution
Not all ECDSA keys are valid ThingsIX gateway keys. Please read the next section
careful to generate a valid ThingsIX gateway key.
:::

#### Gateway key
The gateways public key is used to identify a gateway. Public keys are often
represented by the X and Y value (both 256 bits) and prefixed with `0x04` to
mark it as an uncompressed public key. This totals up to 520 bit. Ethereum and
Polygon both use the Ethereum Virtual Machine (EVM) that operates on 256 bits
storage slots. Therefore storing an uncompressed key requires 3 storage slots.

These slots are expensive. Since the Y value can be
[calculated](https://neuromancer.sk/std/nist/P-256) from the X value ThingsIX
stores the compressed format of the public key. This is the X coordinate without
the Y value. Due to characteristics of the EC curve for each X coordinate there
are 2 valid Y coordinates (even and odd). Therefore the exact public key can not
be derived from just the X coordinate. This is solved by prefixing the X
coordinate with a `0x02` (even) or `0x03` (odd) byte. With this information the
full public key can always be calculated from its compact form. The downside is
that the X coordinate with byte prefix is 264 bits long and requires 2 expensive
storage slots.

ECDSA provides enough security margin to apply a trick. ThingsIX only accepts
"even" gateway keys. These are keys from which the compressed public key would
start with the `0x02` prefix. The registry stores only the X value and when the
public key is needed the X value is prefix with `0x02` to assemble the 
compressed public key. Since the X coordinate without the prefix is 256 bits it
fits in 1 storage slot. The downside is that only the "even" keys are valid and
there is no efficient method to generate valid ThingsIX keys. Since half of the
keys are valid a brute force approach to simply generate keypairs until a valid
ThingsIX keypair is created is practically feasible.

Here are some examples how to generate a valid ThingsIX gateway key:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="shell" label="shell">

```shell
#!/usr/bin/env sh

set -e

GATEWAY_PRIVATE_KEY_FILE=gateway-private-key.pem

while :
do
    # generate gateway key
    openssl ecparam -name secp256k1 -rand /dev/random -genkey -noout -out $GATEWAY_PRIVATE_KEY_FILE 2> /dev/null
    # accept key if its public key is even
    COMPRESSED_PUB_KEY=$(openssl ec -in $GATEWAY_PRIVATE_KEY_FILE -pubout -conv_form compressed -outform der 2> /dev/null | tail -c 33 | xxd -p -c 33)
    case $COMPRESSED_PUB_KEY in 02*)
        echo "gateway private key stored in: $GATEWAY_PRIVATE_KEY_FILE"
        echo "        compressed public key: $COMPRESSED_PUB_KEY"
        exit
    esac
done
```

</TabItem>

<TabItem value="js" label="javascript">

```js
const { randomBytes } = require('crypto');
const secp256k1 = require('secp256k1');

function generateGatewayKey() {
   for (;;) {
      // generate random gateway key and test if it's on the EC curve
      const privateKey = randomBytes(32);
      if (secp256k1.privateKeyVerify(privateKey)) {
         // accept key if its public key is even
         const compressedPublicKey = secp256k1.publicKeyCreate(privateKey);
         if (compressedPublicKey[0] == 0x02) {
            return privateKey;
         }
      }
   }
}
```

</TabItem>

<TabItem value="rust" label="rust">

```rust
use p256::ecdsa::{SigningKey, VerifyingKey};
use sec1::point::Tag;
use rand_core::OsRng;

fn generate_gateway_key() -> SigningKey {
   loop {
      // generate gateway key
      let key = SigningKey::random(&mut OsRng);
      // accept key if its public key is even
      let pub_key_point = VerifyingKey::from(&key).to_encoded_point(true);
      if pub_key_point.tag() == Tag::CompressedEvenY {
         return key;
      };
   }
}
```
</TabItem>
</Tabs>

## Onboard
ThingsIX provides several methods to onboard gateways. From a simple onboarding
procedure where the gateway owner let the gateway sign an onboarding message
that is then sent to the registry smart contract in a chain transaction to more
advanced methods such as offline signing or using gasless transactions through
solutions such as [openzeppelin defender](https://www.openzeppelin.com/defender)
or [GSN](https://opengsn.org).

Each gateway that is onboarded will costs en onboarding fee that is paid in
`THIX` tokens. The conversation rate between USD and `THIX` is kept in a pricing
smart contract that is periodically updated. The registry will use this pricing
smart contract to determine how many `THIX` tokens are burned to pay for the
gateway onboard fee. That means that the owner needs to posses enough `THIX`
tokens to pay for this fee.

### Onboard with owner chain transaction
This is the most simple method of onboarding a gateway. The owner has created an
Ethereum/Polygon account with this wallet and has enought ether or matic in this
account to submit the gateway onboard transaction to the registry and enough
`THIX` tokens in this account to pay for the onboard fee in this account. The
address of this account is included in the onboard message that the gateway.

The first thing to do is to assemble the onboard message, calculate the
keccack-256 hash over this message and sign this hash with the gateway private
key.

The onboard message contains the following fields:

| Field    |      Description      | Type     |
|:----------|:-------------|:-------------|
| chainId | unique chain identifier, see https://chainlist.org | number |
| registry address | registry smart contract address  | address / byte[20] |
| nonce | gateway nonce to prevent replay attack | number |
| gatewayPublicKey | gateway compressed public key (including the `0x02` prefix) | byte[33] |
| ownerEthAddress | owner public address | address / byte[20] |

Since the onboard message is sent to the registry in an on chain transaction it
is public information. To prevent the message to be abused in replay attacks the
`chainId` and `registry address` are included to scope the message to a
particular registry .

The nonce is a per gateway specific nonce that the registry keeps track of. This
is to make the onboard message only valid once. The nonce can be retrieved from
the registry using the gateway public identity.

<Tabs>
<TabItem value="js" label="javascript">

```js
// Sign gateway onboard message that is send to the registry.
// @param gatewayRegistry web3 instance of the smart contract gateway registry
// @param gatewayPrivateKey gateway ECDSA private key to sign the onboard message
// @param gatewayPublicKey compressed public gateway key including the 0x02 prefix (total length 33 bytes)
// @param ownerEthAddress Ethereum address of the gateway owner
function signOnboardMsg(gatewayRegistry, gatewayPrivateKey, gatewayPublicKey, ownerEthAddress) {
   const chainId = await web3.eth.getChainId();
   const nonce = await gatewayRegistry.gatewaySignatureNonce(gatewayPublicKey.substring(1));
   const message = web3.utils.encodePacked(
      {value: "THINGSIX_ONBOARD_GATEWAY_M0", type: "string"},
      {value: "|", type: "string"},
      {value: chainId, type: "uint256"},
      {value: "|", type: "string"},
      {value: gatewayRegistry.address, type: "address"},
      {value: "|", type: "string"},
      {value: nonce, type: "uint256"},
      {value: "|", type: "string"},
      {value: gatewayPublicKey, type: "bytes"},
      {value: "|", type: "string"},
      {value: ownerEthAddress, type: "address"}
   );
   const hash = keccak256(message);
   const hashBytes = Uint8Array.from(Buffer.from(hash.substring(2), 'hex'));
   const sigResult = secp256k1.ecdsaSign(hashBytes, gatewayPrivateKey);

   // the signature must include the recovery id
   switch (sigResult.recid) {
      case 0x0:
         return toHexString(sigResult.signature) + "1B";
      case 0x1:
         return toHexString(sigResult.signature) + "1C";
   }
   throw new Error("invalid recovery id");
}
```
</TabItem>
<TabItem value="web3 ABI" label="web3 ABI">
   ToDo(BvK): include ABI of onboard validator
</TabItem>
</Tabs>
